<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AccelStepperI2C: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AccelStepperI2C
   &#160;<span id="projectnumber">v0.2.2</span>
   </div>
   <div id="projectbrief">I2C wrapper (and a bit more) for the AccelStepper Arduino library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is an I2C wrapper for Mike McCauley's <a href="https://www.airspayce.com/mikem/arduino/AccelStepper/index.html">AccelStepper library</a> with support for two end stops per stepper and optional servo and pin-expander support. It consists of an Arduino-based <b>firmware</b> for one or more I2C-slaves, and corresponding Arduino <b>libraries</b> for the I2C-master. Think of it as a more accessible and more flexible replacement for dedicated I2C stepper motor controller ICs like AMIS-30622, PCA9629 or TMC223 with some extra bells and whistles. Use it with your own hardware or with a plain stepper driver shield like the Protoneer CNC GRBL shield (recent <a href="https://www.elecrow.com/arduino-cnc-shield-v3-51-grbl-v0-9-compatible-uses-pololu-drivers.html">V3.51</a> or <a href="https://forum.protoneer.co.nz/viewforum.php?f=17">V3.00 clone</a>).</p>
<p>The firmware has been tested on ATmega328 Arduino (Uno, Nano etc.), ESP8266 and ESP32 platforms. I expect it should work on other Arduino supported platforms.</p>
<p><a href="https://github.com/ftjuh/AccelStepperI2C">Download AccelStepperI2C on github.</a></p>
<p><a href="https://ftjuh.github.io/AccelStepperI2C/">AccelStepperI2C library documentation</a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
How does it work?</h1>
<ul>
<li>One or more Arduino-likes, acting as <b>I2C-slaves</b>, drive up to eight stepper motors each. The slaves run the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> firmware (<a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/firmware/firmware.ino">firmware.ino</a>), which exposes the AccelStepper functionality via I2C, and additionally supports up to two end stop switches per stepper.</li>
<li>Another device, acting as <b>I2C-master</b>, controls the slave(s) via I2C with the help of the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> library. <a href="https://ftjuh.github.io/AccelStepperI2C/class_accel_stepper_i2_c.html">Its interface</a> is largely identical to the original AccelStepper library.</li>
<li>If <b>servo support</b> is enabled at compile time, unused slave pins can be used to attach servos which the master controls with help of the <a class="el" href="class_servo_i2_c.html" title="An I2C wrapper class for the Arduino Servo library.">ServoI2C</a> library. <a href="https://ftjuh.github.io/AccelStepperI2C/class_servo_i2_c.html">Its interface</a> is largely identical to the original Servo library.</li>
<li>If <b>pin control support</b> is enabled at compile time, unused digital and analog slave pins can be used as remote inputs or outputs with help of the <a class="el" href="class_pin_i2_c.html" title="An I2C wrapper class for remote analog and digital pin control.">PinI2C</a> library, similar to I2C port expanders. <a href="https://ftjuh.github.io/AccelStepperI2C/class_pin_i2_c.html">Its interface</a> is largely identical to the original Arduino pin control functions like digitalRead() or analogWrite().</li>
<li>Internally, the slave is represented by an object of class <b><a class="el" href="class_i2_cwrapper.html" title="A helper class for the AccelStepperI2C and related libraries.">I2Cwrapper</a></b>. <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a>, <a class="el" href="class_servo_i2_c.html" title="An I2C wrapper class for the Arduino Servo library.">ServoI2C</a> and <a class="el" href="class_pin_i2_c.html" title="An I2C wrapper class for remote analog and digital pin control.">PinI2C</a> objects use an <a class="el" href="class_i2_cwrapper.html" title="A helper class for the AccelStepperI2C and related libraries.">I2Cwrapper</a> object for communication with the slave. All general communication with the slave (e.g. reset or error handling) is managed by the <a class="el" href="class_i2_cwrapper.html" title="A helper class for the AccelStepperI2C and related libraries.">I2Cwrapper</a> object, while all communication with a device unit (stepper or servo) is managed by an <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> or <a class="el" href="class_servo_i2_c.html" title="An I2C wrapper class for the Arduino Servo library.">ServoI2C</a> object.</li>
</ul>
<p>Refer to the <a href="#example">example below</a> and the <a href="https://github.com/ftjuh/AccelStepperI2C/tree/master/examples">examples folder</a> to see how it works in detail.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Differences from AccelStepper</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
State machine vs. polling</h2>
<p>The original AccelStepper needs the client to <b>constantly 'poll'</b> each stepper by invoking one of the run() commands (run(), runSpeed(), or runSpeedToPosition()) at a frequency which mustn't be lower than the stepping frequency. Over I2C, this would clutter the bus, put limits on stepper speeds, and be unstable if there are other I2C devices on the bus, particularly with multiple steppers and microstepping.</p>
<p>To solve this problem, the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> firmware implements a <b>state machine</b> for each connected stepper which makes the slave do the polling locally on its own.</p>
<p>All the master has to do is make the appropriate settings, e.g. set a target with <a class="el" href="class_accel_stepper_i2_c.html#a06ee86271f675746386c4cb86b6c6182">AccelStepperI2C::moveTo()</a> or choose a speed with <a class="el" href="class_accel_stepper_i2_c.html#a2a8c92150ae055c7ff696ff98ddb7a38">AccelStepperI2C::setSpeed()</a> and then start the slave's state machine (see example below) with one of</p><ul>
<li><a class="el" href="class_accel_stepper_i2_c.html#a934c71dc0f3b534bc859f40e785066b6" title="Will poll run(), i.e. run to the target with acceleration and stop the state machine upon reaching it...">AccelStepperI2C::runState()</a>: will poll run(), i.e. run to the target with acceleration, and stop the state machine upon reaching it</li>
<li><a class="el" href="class_accel_stepper_i2_c.html#a60f56e376242af7fe69fda51c6758ec7" title="Will poll runSpeed(), i.e. run at constant speed until told otherwise (see AccelStepperI2C::stopState...">AccelStepperI2C::runSpeedState()</a>: will poll runSpeed(), i.e. run at constant speed until told otherwise (see <a class="el" href="class_accel_stepper_i2_c.html#a509c7691efe52e80615e937e693bdbc1" title="Will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely i...">AccelStepperI2C::stopState()</a>), or</li>
<li><a class="el" href="class_accel_stepper_i2_c.html#a935522089c48b23c0e9f17b242d7d94f" title="Will poll runSpeedToPosition(), i.e. run at constant speed until target has been reached.">AccelStepperI2C::runSpeedToPositionState()</a>: will poll runSpeedToPosition(), i.e. run at constant speed until the target has been reached.</li>
</ul>
<p><a class="el" href="class_accel_stepper_i2_c.html#a509c7691efe52e80615e937e693bdbc1" title="Will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely i...">AccelStepperI2C::stopState()</a> will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely in command of target, speed, and other settings.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Additional features</h2>
<ul>
<li>Up to two <b>end stop switches</b> can be defined for each stepper. If enabled and the stepper runs into one of them, it will make the state machine (and the stepper motor) stop. Of course, this is most useful in combination with <a class="el" href="class_accel_stepper_i2_c.html#a60f56e376242af7fe69fda51c6758ec7" title="Will poll runSpeed(), i.e. run at constant speed until told otherwise (see AccelStepperI2C::stopState...">AccelStepperI2C::runSpeedState()</a> for homing and calibration tasks at startup. See <a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/examples/Interrupt_Endstop/Interrupt_Endstop.ino">Interrupt_Endstop.ino</a> example for a use case.</li>
<li>An <b>interrupt pin</b> can be defined which informs the master that the state machine's state has changed. Currently, this will happen when a set target has been reached or when an endstop switch was triggered. See <a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/examples/Interrupt_Endstop/Interrupt_Endstop.ino">Interrupt_Endstop.ino</a> example for a use case.</li>
<li>The <b>slave's I2C address</b> (default: 0x8) can be permanently changed without recompiling the firmware.</li>
<li>I2C transmission <b>error checking</b> is available and recommended in critical situations (see <a href="#error-handling">Error handling</a>).</li>
<li><b>Speed diagnostics</b> are available (see <a href="#performance-and-diagnostics">Performance and diagnostics</a>).</li>
<li><b>Servo support</b> is available (see above and the <a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/examples/Servo_Sweep/Servo_Sweep.ino">Servo_sweep.ino</a> and <a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/examples/Stepper_and_Servo_together/Stepper_and_Servo_together.ino">Stepper_and_Servo_together.ino</a> examples). Can be disabled at compile time.</li>
<li>(New in v0.1.1) <b>Pin control support</b> is available (see above and the <a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/examples/Pin_control/Pin_control.ino">Pin_control.ino</a> example). Can be disabled at compile time.</li>
<li>The project has grown into a <b>framework</b> which could easily be extended to provide other additional slave capabilities like driving DC motors <strike>or using remote pins (I/O extender like)</strike> in the future.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Restrictions</h2>
<ul>
<li>The original run(), runSpeed(), or runSpeedToPosition() functions are implemented, but it is <b>discouraged to use them directly</b>. The idea of these functions is that they are called as often as possible which would cause constant I2C traffic. The I2C protocol was not designed for this kind of traffic, so use the state machine instead. If you feel you <em>must</em> use the original ones, take it slowly and see if your setup, taking other I2C devices into consideration, allows you to <a href="https://www.arduino.cc/en/Reference/WireSetClock">increase the I2C bus frequency</a>. Even then you shouldn't poll as often as possible (as AccelStepper usually wants you to), but adjust the polling frequency to you max. stepping frequency, to allow the I2C bus some room to breathe.</li>
<li>Each library function call, its parameters, and possibly a return value has to be transmitted back and forth via I2C. This makes things <b>slower, less precise, and prone to errors</b>. To be safe from errors, you'll need to do some extra checking (see <a href="#error-handling">Error handling</a>).</li>
<li>No <b>serialization protocol</b> is used at the moment, so the implementation is machine dependent in regard to the endians and sizes of data types. Arduinos Uno/Nano, ESP8266 and ESP32 have been tested and work well together, as should other Arduino supporting platforms.</li>
<li>Naturally, you cannot declare your own stepping functions with the <a href="https://www.airspayce.com/mikem/arduino/AccelStepper/classAccelStepper.html#afa3061ce813303a8f2fa206ee8d012bd">constructor [2/2] variant</a>.</li>
<li><strike>The two blocking functions, <b>runToPosition() and runToNewPosition()</b>, are not implemented at the moment. I never saw their purpose, anyway, as their behavior can easily implemented with the existing functionality.</strike></li>
<li><strike>There is no interrupt mechanism at the moment which tells the master that a state machine job has finished or an endstop has been triggered. So the master still needs to poll the slave with one of <a class="el" href="class_accel_stepper_i2_c.html#a26e27bf5d72113dc43694c87ed4a75f4">AccelStepperI2C::distanceToGo()</a>, <a class="el" href="class_accel_stepper_i2_c.html#ac3a25dd2091e8b7a2aaa415150957b7e">AccelStepperI2C::currentPosition</a>, <a class="el" href="class_accel_stepper_i2_c.html#a5d61e5c0ac971764de463e1d958a517d">AccelStepperI2C::isRunning()</a>, or <a class="el" href="class_accel_stepper_i2_c.html#af27f8157184e75d824faa9634113c67c" title="Read current raw, i.e. not debounced state of endstops. It&#39;s basically one or two digitalReads() comb...">AccelStepperI2C::endstops()</a> but can do so at a much more reasonable frequency.</strike></li>
<li><strike>Currently, there is no error checking of the master-slave communication, which uses a very basic (i.e. non existing) protocol. The master will have to deal with any transmission errors should they occur.</strike></li>
</ul>
<p>Have a look at the <a href="https://ftjuh.github.io/AccelStepperI2C/todo.html">todo list</a> to see what improvements are still planned.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Usage</h1>
<p>A warning up front: Uncontrollably moving stepper motors can break things. So take care of <b><a href="#error-handling">error handling</a></b> and <b><a href="#safety-precautions">safety precautions</a></b> in critical environments e.g. if your steppers gone wild might damage something.</p>
<ol type="1">
<li>Install the folder with the libraries <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a>, <a class="el" href="class_simple_buffer.html">SimpleBuffer</a>, <a class="el" href="class_i2_cwrapper.html" title="A helper class for the AccelStepperI2C and related libraries.">I2Cwrapper</a> (<a class="el" href="class_servo_i2_c.html" title="An I2C wrapper class for the Arduino Servo library.">ServoI2C</a> and <a class="el" href="class_pin_i2_c.html" title="An I2C wrapper class for remote analog and digital pin control.">PinI2C</a>, if used) and of course the original AccelStepper <a href="https://docs.arduino.cc/software/ide-v1/tutorials/installing-libraries#manual-installation">to the Arduino environment</a>.</li>
<li>Upload <a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/firmware/firmware.ino">firmware.ino</a> to one Arduino (slave), there are a couple of configuration options at the top of the file. Connect steppers and stepper drivers to the slave or use a dedicated hardware, e.g. Arduino UNO with CNC V3.00 shield.</li>
<li>Upload an example sketch or your own master sketch to another Arduino-like (master).</li>
<li>Connect the I2C bus of both devices, usually it's A4&lt;-&gt;A4 (SDA), A5&lt;-&gt;A5 (SCL) and GND&lt;-&gt;GND. Don't fortget two I2C pullups and, if needed, level-shifters. Also connect +5V&lt;-&gt;+5V to power one board from the other, if needed.</li>
<li>Now (not earlier) provide external power to the steppers and power to the Arduinos.</li>
</ol>
<p>Have a look at the <a href="https://github.com/ftjuh/AccelStepperI2C/tree/master/examples">examples</a> for details.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Error handling</h2>
<p>If I2C transmission problems occur, any call to the library could fail and, possibly worse, every return value could be corrupted. Uncontrolled or unexpected stepper movements could lead to serious problems (see below). That's why each command and response is sent with a CRC8 checksum. To find out if a master's command or a slave's response was <b>transmitted correctly</b>, the master can check the following:</p>
<ul>
<li>If <a class="el" href="class_i2_cwrapper.html#a51c3023339571c205c161a82576fd4f4" title="True if previous function call was successfully transferred to slave.">I2Cwrapper::sentOK</a> is false, the previous function call was not properly transmitted.</li>
<li>If <a class="el" href="class_i2_cwrapper.html#abf0d76a351cee8c7ce48f87d13e27dbc" title="True if return value from previous function call was received successfully.">I2Cwrapper::resultOK</a> is false, the data returned from the previous function call is invalid.</li>
</ul>
<p>The library keeps an internal count of the <b>number of failed transmissions</b>, i.e. the number of cases that sentOK and resultOK came back false. If the master doesn't want to check each transmission separately, it can use one of the following methods at the end of a sequence of transmissions (e.g. setup and configuration of the slave or at the end of some program loop):</p>
<ul>
<li>uint16_t <a class="el" href="class_i2_cwrapper.html#a99818d9f4b28834ce7611759c6b45032" title="Return and reset the number of failed commands sent since the last time this method was used....">I2Cwrapper::sentErrors()</a> - number of false sentOK events</li>
<li>uint16_t <a class="el" href="class_i2_cwrapper.html#a595582aa091af76fc27c472d081db4db" title="Return and reset the number of failed receive events since the last time this method was used....">I2Cwrapper::resultErrors()</a> - number of false resultOK events</li>
<li>uint16_t <a class="el" href="class_i2_cwrapper.html#af26fad87074cea9cf636cbd49226c8c5" title="Return and reset the sum of failed commands sent and failed receive events since the last time this m...">I2Cwrapper::transmissionErrors()</a> - sum of the above</li>
</ul>
<p>The respective counter(s) will be reset to 0 with each invocation of these methods.</p>
<p>See the <a href="https://github.com/ftjuh/AccelStepperI2C/blob/master/examples/Error_checking/Error_checking.ino">Error_checking.ino</a> example for further illustration.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Safety precautions</h2>
<p>Steppers can exert damaging forces, even if they are moving slow. If in doubt, set up your system in a way that errors will not break things, particularly during testing:</p>
<ul>
<li>Place your end stops in a <b>non-blocking position</b> so that they are activated in a by-passing way but do not block the way themselves.</li>
<li>To be really safe, put <b>emergency stops</b> which shut down the slave in a final end position. Currently there is no dedicated pin mechanism for that, so just use the slave's reset pin instead.</li>
<li>Always keep a <b>manual emergency stop</b> at hand or make it easy to cut the power quickly.</li>
<li>And again, do check for transmission errors in critical situations (see <b><a href="#error-handling">error handling</a></b>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Troubleshooting</h2>
<p>If things don't work as expected, here's a couple of things that helped me during testing:</p>
<ul>
<li>Start <b>without I2C</b>. That is, after setting up the hardware, first test the to-be-slave device with a conventional AccelStepper sketch, so that you can be sure your problems are I2C-related.</li>
<li>Start <b>without steppers</b>. Use error handling and possibly debug output to test if communication between master and slave is working as it should.</li>
<li><b>Simplify</b>. Start with very simple setups, short cables, low bus speeds etc. and work your way up from there. Don't mix platforms, start with two Uno/Nanos.</li>
<li>Did you think of two <b>I2C-pullups</b>?</li>
<li>Have you powered your <b>level shifters</b>? They won't work with SCL, SDA and GND alone.</li>
<li>If master and slave run on different hardware platforms, <b>pin names</b> like "LED_BUILTIN" or D3" might refer to completely different hardware pins or not be defined at all.  For example, when using a ESP8266 Wemos d1 mini as slave, a master sketch for the Arduino Uno cannot use "D3" as it is undefined, and, even worse, a master sketch compiled for some ESP32 device will translate it to a completely different hardware pin.  So when addressing slave pins from the master's side, it's safest to use the integer equivalents of names like "D3". Look them up in the <code>pins_arduino.h</code> file for your slave device or run a simple sketch with <code>Serial.print(D3);</code> etc. on your slave board.</li>
<li>ESPs can crash if you unintentionally use certain pin numbers (e.g. flash memory pins) that are available on plain Unos/Nanos. Remember that when you <b>move between platforms</b>.</li>
<li>Enable <b>debug output</b> on slave <em>and</em> master. It's a bit cluttered at the moment, yet informative. To see both master and slave output simultaneously, you need to open slave and master sketch from two independently started Arduino instances, i.e. don't use the open dialogue from your master's sketch to open the firmware sketch, instead start the program a second time. Only then you can open two separate serial output windows after choosing the two USB ports.</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
Performance and diagnostics</h1>
<p>On a normal ATmega328 @ 16MHz, the original AccelStepper supposedly can run <a href="https://www.airspayce.com/mikem/arduino/AccelStepper/classAccelStepper.html#details">about 4000 steps per second</a>. The <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> state machine only takes a tiny bite away from that. However, if you are using a lot of steppers, need high speeds, and/or if you are using a big microstepping factor, a normal Arduino can quickly become too slow. So choose your platform wisely, the ESP32 will be 10-20 times faster.</p>
<p>DEBUG output, which can be enabled for all parts of this software individually, will report a simple cycles/second statistic to Serial for the slave's state machine. This, however, will be distorted by the time needed for serial output.</p>
<p>If the slave firmware was compiled with the DIAGNOSTICS compiler directive, more elaborate and more reliable speed measurements are available. You can use the diagnostics() function to investigate the system performance. It will use a struct of type <a class="el" href="structdiagnostics_report.html">diagnosticsReport</a> with information on</p>
<ul>
<li>the time needed to process (interpret) the most recently received command,</li>
<li>the time the slave spent in the most recent onRequest() interrupt,</li>
<li>the time the slave spent in the most recent onReceive() interrupt, and</li>
<li>the number of main loop executions since the last reboot. You can use this number to determine the frequency with which active state machines poll the AccelStepper library. This frequency always needs to be higher than the stepping frequency. Be warned that it is heavily influenced by the incidence of speed recalculations that the library does during acceleration and deceleration. Any change in one of the relevant parameters, e.g. acceleration factor or distance to target, will influence this incidence. So you'll need to determine the polling frequency under your specific real world conditions, not under some dry run testing conditions.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Supported platforms</h1>
<p>The following platforms will run the slave firmware and have been (more or less) tested. Unfortunately, they all have their pros and cons:</p>
<ul>
<li><b>Arduino AVRs (Uno, Nano etc.)</b>: Comes with I2C hardware support which should make communication most reliable and allows driving the I2C bus at higher frequencies. With only 16MHz CPU speed not recommended for high performance situations with many steppers, microstepping and high speeds.</li>
<li><b>ESP8266</b>: Has no I2C hardware. The software I2C will not work stable at the default 80MHz CPU speed, make sure to configure the <b>CPU clock speed to 160MHz</b>. Even then, it might be necessary to <a href="https://www.arduino.cc/en/Reference/WireSetClock">decrease the bus speed</a> below 100kHz for stable bus performance, start as low as 10kHz if in doubt. Apart from that, expect a performance increase of ca. 10-15x vs. plain Arduinos due to higher CPU clock speed and better hardware support for math calculations.</li>
<li><b>ESP32</b>: Has no I2C hardware. I2C is stable at the default 240MHz, but officially cannot run faster than 100kHz. Also, the slave implementation is awkward. It might be more susceptible for I2C transmission errors, so timing is critical (see AccelStepperI2C::setI2Cdelay()). Apart from that, expect a performance increase of ca. 15-20x vs. plain Arduinos due to higher CPU clock speed and better hardware support for math calculations.</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Example</h1>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/*</div>
<div class="line">   AccelStepperI2C Bounce demo</div>
<div class="line">   (c) juh 2022</div>
<div class="line">   </div>
<div class="line">   This is a 1:1 equivalent of the AccelStepper Bounce.pde example</div>
<div class="line">   https://www.airspayce.com/mikem/arduino/AccelStepper/Bounce_8pde-example.html</div>
<div class="line">*/</div>
<div class="line"> </div>
<div class="line">#include &lt;Wire.h&gt;</div>
<div class="line">#include &lt;AccelStepperI2C.h&gt;</div>
<div class="line"> </div>
<div class="line">uint8_t i2cAddress = 0x08;</div>
<div class="line"> </div>
<div class="line">I2Cwrapper wrapper(i2cAddress); // each slave device is represented by a wrapper...</div>
<div class="line">AccelStepperI2C stepper(&amp;wrapper); // ...that the stepper needs to communicate with it</div>
<div class="line"> </div>
<div class="line">void setup()</div>
<div class="line">{  </div>
<div class="line">  Wire.begin();</div>
<div class="line">  // Wire.setClock(10000); // uncomment for ESP8266 slaves, to be on the safe side</div>
<div class="line"> </div>
<div class="line">  if (!wrapper.ping()) {</div>
<div class="line">    Serial.println(&quot;Slave not found! Check connections and restart.&quot;);</div>
<div class="line">    while (true) {}</div>
<div class="line">  }  </div>
<div class="line">  wrapper.reset(); // reset the slave device</div>
<div class="line">  delay(500); // and give it time to reboot</div>
<div class="line">  </div>
<div class="line">  stepper.attach(); // Defaults to AccelStepper::FULL4WIRE (4 pins) on 2, 3, 4, 5</div>
<div class="line">  // attach() replaces the AccelStepper constructor, so it could also be called like this: </div>
<div class="line">  // stepper.attach(AccelStepper::DRIVER, 5, 6);</div>
<div class="line">  </div>
<div class="line">  if (stepper.myNum &lt; 0) { // stepper could not be allocated (should not happen after a reset)</div>
<div class="line">    while (true) {}</div>
<div class="line">  }</div>
<div class="line">    </div>
<div class="line">  // Change these to suit your stepper if you want</div>
<div class="line">  stepper.setMaxSpeed(500);</div>
<div class="line">  stepper.setAcceleration(100);</div>
<div class="line">  stepper.moveTo(2000);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/* This is the recommended AccelStepperI2C implementation using the state machine.</div>
<div class="line"> * Note that the polling frequency is not critical, as the state machine will stop </div>
<div class="line"> * on its own. So even if stepper.distanceToGo() causes some I2C traffic, it will be </div>
<div class="line"> * substantially less traffic than sending each stepper step seperately (see below).</div>
<div class="line"> * If you want to cut down I2C polling completely, you can use the interrupt mechanism </div>
<div class="line"> * (see Interrupt_Endstop.ino example sketch).</div>
<div class="line"> */</div>
<div class="line">void loop()</div>
<div class="line">{</div>
<div class="line">  stepper.runState(); // start the state machine with the set target and parameters</div>
<div class="line">  while (stepper.distanceToGo() != 0) { // wait until target has been reached</div>
<div class="line">    delay(250); // just to demonstrate that polling frequency is not critical</div>
<div class="line">  }</div>
<div class="line">  stepper.moveTo(-stepper.currentPosition());   </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/* This is the &quot;classic&quot; implementation which uses the original polling functions. </div>
<div class="line"> * It will work, at least in low performance situations, but will clog the I2C bus as </div>
<div class="line"> * each (attempted) single stepper step needs to be sent via I2C.</div>
<div class="line"> */</div>
<div class="line">void loopClassic()</div>
<div class="line">{</div>
<div class="line">  if (stepper.distanceToGo() == 0)</div>
<div class="line">    stepper.moveTo(-stepper.currentPosition());</div>
<div class="line">  stepper.run(); // frequency is critical, each call will cause I2C traffic</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Documentation</h1>
<p><a href="https://ftjuh.github.io/AccelStepperI2C/">Find the AccelStepperI2C library documentation here</a>. It only deals with differences from running the AccelStepper library locally. If not stated otherwise, expect <a class="el" href="class_accel_stepper_i2_c.html">functions and parameters</a> to work as in the original, keeping the above differences and restrictions in mind.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Author</h1>
<p>This is my first "serious" piece of software published on github. Although I've some background in programming, mostly in the Wirth-tradition languages, I'm far from being a competent or even avid c++ programmer. At the same time I have a tendency to over-engineer (not a good combination), so be warned and use this at your own risk. My current main interest is in 3D printing, you can find me on <a href="https://www.prusaprinters.org/social/202816-juh/about">prusaprinters</a>, <a href="https://www.thingiverse.com/juh/designs">thingiverse</a>, and <a href="https://www.youmagine.com/juh3d/designs">youmagine</a>. This library was developed as part of my <a href="https://www.prusaprinters.org/prints/115049-stepfish-fischertechnik-i2c-stepper-motor-controll">StepFish project</a> (<a href="https://forum.ftcommunity.de/viewtopic.php?t=5341">also here</a>).</p>
<p>Contact me at <a href="#" onclick="location.href='mai'+'lto:'+'ftj'+'uh'+'@po'+'st'+'eo.'+'ne'+'t'; return false;">ftjuh<span style="display: none;">.nosp@m.</span>@pos<span style="display: none;">.nosp@m.</span>teo.n<span style="display: none;">.nosp@m.</span>et</a>.</p>
<p>Jan (juh)</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Copyright</h1>
<p>This software is Copyright (C) 2022 juh (<a href="#" onclick="location.href='mai'+'lto:'+'ftj'+'uh'+'@po'+'st'+'eo.'+'ne'+'t'; return false;">ftjuh<span style="display: none;">.nosp@m.</span>@pos<span style="display: none;">.nosp@m.</span>teo.n<span style="display: none;">.nosp@m.</span>et</a>)</p>
<h1><a class="anchor" id="autotoc_md16"></a>
License</h1>
<p><a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> is distributed under the GNU GENERAL PUBLIC LICENSE Version 2.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
History</h1>
<p>v0.1.0 Initial release</p>
<p>v0.1.1 Fixed I2Cdelay;</p>
<p>v0.2.0 Added pin control support (<a class="el" href="_pin_i2_c_8h.html" title="Arduino library for I2C-control of digital and analog pins connected to another Arduino which runs th...">PinI2C.h</a> and <a class="el" href="_pin_i2_c_8cpp.html" title="Part of the AccelStepperI2C firmware/library.">PinI2C.cpp</a>) for reading and writing unused slave pins; Restructured folder layout to prepare for submission as third party library to the Arduino library manager.</p>
<p>v0.2.1 minor maintainence</p>
<p>v0.2.2 dummy release, as the library manager for some reason did not pick up v0.2.1 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 19 2022 22:58:04 for AccelStepperI2C by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
